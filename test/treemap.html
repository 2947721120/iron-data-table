<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../test-fixture/test-fixture-mocha.js"></script>
  <link rel="import" href="common.html">
  <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
  <link rel="import" href="../iron-data-table.html">
</head>

<body>
  <script>
    var TreeMap = function() {
      var nodes = [];

      var _findFirst = function(index) {
        var items = nodes.filter(function(n) {
          return n.start <= index && n.end >= index;
        });

        return (items && items.length > 0) ? items[0] : null;
      };

      var _findPath = function(path) {
        return nodes.filter(function(n) {
          return n.path === path;
        });
      };

      var _updateIndexes = function() {
        var start = 0;

        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];

          var length = node.end - node.start;
          node.start = start;
          node.end = start + length;

          start += length + 1;
        }
      };

      var _combineSiblings = function() {
        for (var i = 0; i < nodes.length; i++) {
          if (i + 1 < nodes.length) {
            var node = nodes[i];
            var nextNode = nodes[i + 1];

            if (node.path === nextNode.path) {
              node.end = nextNode.end;
              nodes.splice(i + 1, 1);

              _combineSiblings();
              return;
            }
          }


        }
      };

      return {
        add: function(path, index, count) {
          if (_findPath(path).length > 0) {
            throw Error(path + ' already added.');
          }

          var newNode = {path: path, start: index, end: index + count - 1, count: count};

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (node.start <= index && node.end >= index) {
              var splittedStart = {path: node.path, start: node.start, end: index - 1, count: node.count};
              var splittedEnd = {path: node.path, start: index + count, end: index + count + (node.end - node.start) - (splittedStart.end - splittedStart.start) - 1, count: node.count};
              nodes.splice(i, 1, splittedStart, newNode, splittedEnd);

              _updateIndexes();
              return;
            }
          }
          nodes.push(newNode);
        },

        remove: function(path) {
          var indexes = _findPath(path).map(function(p) {
            return nodes.indexOf(p);
          });

          var first = indexes[0];
          var last = indexes[indexes.length - 1];

          nodes.splice(first, last - first + 1);

          _updateIndexes();
          _combineSiblings();
        },

        getPath: function(index) {
          var first = _findFirst(index);

          return first ? first.path : undefined;
        },

        //public to help debugging
        _nodes: nodes
      };
    };

    describe('Tree Map', function() {
      var tree;

      beforeEach(function() {
        tree = new TreeMap();
      });

      describe('Returning paths', function() {
        it('should return path on start index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(0)).to.eql('/');
        });

        it('should return path on nested index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(50)).to.eql('/');
        });

        it('should return path on end index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(99)).to.eql('/');
        });

        it('should not return path on missing index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(100)).to.be.undefined;
        });
      });

      describe('Adding nodes', function() {
        it('should add a node', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(0)).to.eql('/');
        });

        it('should not allow adding duplicate paths', function() {
          tree.add('/', 0, 100);

          expect(function() {
            tree.add('/', 0, 100);
          }).to.throw(Error);
        });

        it('should add a second node at the end', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 100, 100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/foo');
        });

        it('should add a second node at the beginning', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 0, 100);

          expect(tree.getPath(99)).to.eql('/foo');
          expect(tree.getPath(100)).to.eql('/');
        });

        it('should add a third node in the middle', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.add('/bar', 100, 100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/bar');
          expect(tree.getPath(199)).to.eql('/bar');
          expect(tree.getPath(200)).to.eql('/foo');
        });

        it('should split a node in half', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 50, 100);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/foo');
          expect(tree.getPath(149)).to.eql('/foo');
          expect(tree.getPath(150)).to.eql('/');
        });

        it('should update indexes after splitting', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.add('/bar', 50, 100);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/bar');
          expect(tree.getPath(149)).to.eql('/bar');
          expect(tree.getPath(150)).to.eql('/');
          expect(tree.getPath(199)).to.eql('/');
          expect(tree.getPath(200)).to.eql('/foo');
        });
      });

      describe('Removing nodes', function() {
        it('should remove a node from the end', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.remove('/foo');

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;
        });

        it('should remove a node from the beginning', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.remove('/');

          expect(tree.getPath(99)).to.eql('/foo');
          expect(tree.getPath(100)).to.be.undefined;
        });

        it('should remove a node from the middle', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);
          tree.add('/bar', 200, 100);

          tree.remove('/foo');

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/bar');
        });

        it('should combine a splitted node', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 50, 100);

          tree.remove('/foo');

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/');
          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;

          expect(tree._nodes.length).to.eql(1);
        });

        it('should remove nested nodes', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 50, 100);
          tree.add('/bar', 100, 100);

          tree.remove('/foo');

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/');
          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;
        });
      });
    });
  </script>

</body>

</html>
