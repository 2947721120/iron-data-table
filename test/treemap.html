<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../test-fixture/test-fixture-mocha.js"></script>
  <link rel="import" href="common.html">
  <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
  <link rel="import" href="../iron-data-table.html">
</head>

<body>
  <script>
    var TreeMap = function() {
      var nodes = [];

      var _findFirst = function(index) {
        var items = nodes.filter(function(n) {
          return n.start <= index && n.end >= index;
        });

        return (items && items.length > 0) ? items[0] : null;
      };

      return {
        add: function(path, index, count) {
          var newNode = {path: path, start: index, end: index + count - 1, count: count};

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (node.start <= index && node.end >= index) {
              var splittedStart = {path: node.path, start: node.start, end: index - 1, count: node.count};
              var splittedEnd = {path: node.path, start: index + count, end: index + count + (node.end - node.start) - (splittedStart.end - splittedStart.start) - 1, count: node.count};
              nodes.splice(i, 1, splittedStart, newNode, splittedEnd);
              console.log(nodes);
              return;
            }
          }
          nodes.push(newNode);
          console.log(nodes);
        },

        remove: function(path) {

        },

        getPath: function(index) {
          var first = _findFirst(index);

          return first ? first.path : undefined;
        },

        //public to help debugging
        _nodes: nodes
      };
    };

    describe('Tree Map', function() {
      var tree;

      beforeEach(function() {
        tree = new TreeMap();
      });

      describe('Returning paths', function() {
        it('should return path on start index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(0)).to.eql('/');
        });

        it('should return path on nested index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(50)).to.eql('/');
        });

        it('should return path on end index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(99)).to.eql('/');
        });

        it('should not return path on missing index', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(100)).to.be.undefined;
        });
      });

      describe('Adding nodes', function() {
        it('should add a node', function() {
          tree.add('/', 0, 100);

          expect(tree.getPath(0)).to.eql('/');
        });

        it('should not allow adding duplicate paths', function() {
          tree.add('/', 0, 100);

          expect(function() {
            tree.add('/', 0, 100);
          }).to.throw(Error);
        });

        it('should add a second node at the end', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 100, 100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/foo');
        });

        it('should add a second node at the beginning', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 0, 100);

          expect(tree.getPath(99)).to.eql('/foo');
          expect(tree.getPath(100)).to.eql('/');
        });

        it('should add a third node in the middle', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.add('/bar', 100, 100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/bar');
          expect(tree.getPath(199)).to.eql('/bar');
          expect(tree.getPath(200)).to.eql('/foo');
        });

        it('should split a node in half', function() {
          tree.add('/', 0, 100);

          tree.add('/foo', 50, 100);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/foo');
          expect(tree.getPath(149)).to.eql('/foo');
          expect(tree.getPath(150)).to.eql('/');
        });

        it('should update indexes after splitting', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.add('/bar', 50, 100);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/bar');
          expect(tree.getPath(149)).to.eql('/bar');
          expect(tree.getPath(150)).to.eql('/');
          expect(tree.getPath(199)).to.eql('/');
          expect(tree.getPath(200)).to.eql('/foo');
        });
      });

      describe('Removing nodes', function() {
        it('should remove a node from the end', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.remove(100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;
        });

        it('should remove a node from the beginning', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);

          tree.remove(0);

          expect(tree.getPath(99)).to.eql('/foo');
          expect(tree.getPath(100)).to.be.undefined;
        });

        it('should remove a node from the middle', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 100, 100);
          tree.add('/bar', 200, 100);

          tree.remove(100);

          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.eql('/bar');
        });

        it('should combine a splitted node', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 50, 100);

          tree.remove(50);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/');
          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;
        });

        it('should remove nested nodes', function() {
          tree.add('/', 0, 100);
          tree.add('/foo', 50, 100);
          tree.add('/bar', 100, 100);

          tree.remove(50);

          expect(tree.getPath(49)).to.eql('/');
          expect(tree.getPath(50)).to.eql('/');
          expect(tree.getPath(99)).to.eql('/');
          expect(tree.getPath(100)).to.be.undefined;
        });
      });
    });
  </script>

</body>

</html>
