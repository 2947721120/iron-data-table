<dom-module id="grid-cell">
  <template>
    <content></content>
  </template>
  <script>
    window.vaadin = window.vaadin || {};
    vaadin.elements = vaadin.elements || {};
    vaadin.elements.grid = vaadin.elements.grid || {};
    vaadin.elements.grid.cell = vaadin.elements.grid.cell || 0;

    Polymer({
      is: 'grid-cell',

      properties: {
        template: {
          type: Object,
          observer: '_templateChanged'
        },

        bind: {
          type: Object,
          observer: '_bindChanged'
        },

        column: {
          type: Object,
          observer: '_columnChanged'
        },

        order: {
          type: Number,
          observer: '_orderChanged'
        },

        width: {
          type: String,
          observer: '_widthChanged'
        },

        _contentElement: {
          type: Object
        },

        _content: {
          type: Object
        }
      },

      attached: function() {
        var id = vaadin.elements.grid.cell++;

        this._contentElement = document.createElement('content');
        this._contentElement.setAttribute('select', '#cell' + id);

        this._content = document.createElement('div');
        this._content.id = 'cell' + id;

        this._render();

        Polymer.dom(this).appendChild(this._contentElement);
        Polymer.dom(this.domHost).appendChild(this._content);
        Polymer.dom.flush();
      },

      detached: function() {
        // Polymer.dom(this._content.parentElement) has different childs depending if Shady or native Shadow DOM is used.
        // TODO: see if there's a need to use Polymer.dom here and can it be done somehow.
        this._content.parentElement.removeChild(this._content);

        Polymer.dom(this).removeChild(this._contentElement);
        Polymer.dom.flush();
      },

      _orderChanged: function(order) {
        this.style.order = order;
      },

      _onOrderChanged: function(e) {
        this.order = e.detail.value;
      },

      _widthChanged: function(e) {
        this.style.width = e.detail.value;
      },

      _hiddenChanged: function(e) {
        this.hidden = e.detail.value;
      },

      // data and template might be bound in different order, depending on how <grid-cell>
      // is placed in the DOM. We need to call _render() after they've been both bound.
      _bindChanged: function(data) {
        if (this.column && this.template) {
          if (!this.column._templatized) {
            this._templateChanged(this.template);
          } else {
            if (!this._instance) {
              this._instance = this.column.stamp({item: data});
              this.column._templateInstances.push(this._instance);
              this._render();
            } else {
              this._instance.item = data;
            }
          }
        }
      },

      _columnChanged: function(column) {
        this.order = column.order;

        if (this.template) {
          this._templateChanged(this.template);
        }

        this.listen(column, 'width-changed', '_widthChanged');
        this.listen(column, 'hidden-changed', '_hiddenChanged');
        this.listen(column, 'order-changed', '_onOrderChanged');

        //TODO: remember to unlisten
      },

      _templateChanged: function(template) {
        if (this.column) {
          this.column.templatize(template);
          this._instance = this.column.stamp({});
          this.column.push('_templateInstances', this._instance);

          this._render();

          if (this.bind) {
            this._instance.item = this.bind;
          }
        }
      },

      _render: function() {
        if (this._content && this._instance) {
          this._content.innerHTML = '';

          Polymer.dom(this._content).appendChild(this._instance.root);
          Polymer.dom.flush();
        }
      }
    });
  </script>
</dom-module>
